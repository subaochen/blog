#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass ctex-article
\begin_preamble
\input{/home/subaochen/git/writing-common/article-preamble.tex}
\end_preamble
\use_default_options true
\begin_modules
theorems-bytype
theorems-chap-bytype
coderemarks
note-inset
tip-inset
warning-inset
logicalmkup
\end_modules
\maintain_unincluded_children false
\language chinese-simplified
\language_package default
\inputencoding utf8-plain
\fontencoding global
\font_roman "default" "新宋体"
\font_sans "default" "新宋体"
\font_typewriter "default" "新宋体"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format pdf4
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\boxbgcolor #d8daeb
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Java泛型的类型擦除
\end_layout

\begin_layout Standard
Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会
进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。理解类型擦
除对于用好泛型是很有帮助的，尤其是一些看起来“疑难杂症”的问题，弄明白了类型擦除也就迎刃而解了。
\end_layout

\begin_layout Standard
泛型的类型擦除原则是：
\end_layout

\begin_layout Itemize
消除类型参数声明，即删除<>及其包围的部分。
\end_layout

\begin_layout Itemize
根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则
\begin_inset Note Note
status open

\begin_layout Plain Layout
此处插入子类替换原则的引用
\end_layout

\end_inset

取类型参数的最左边限定类型（即父类）。
\end_layout

\begin_layout Itemize
为了保证类型安全，必要时插入强制类型转换代码。
\end_layout

\begin_layout Itemize
自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。
\begin_inset Note Note
status open

\begin_layout Plain Layout
似乎有问题？
\end_layout

\end_inset


\end_layout

\begin_layout Section
擦除类定义中的类型参数
\end_layout

\begin_layout Subsection
无限制类型擦除
\end_layout

\begin_layout Standard
当类定义中的类型参数没有任何限制时，在类型擦除中直接被替换为Object，即形如<T>和<?>的类型参数都被替换为Object，参见
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
figurename
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:擦除类定义中的类型参数"

\end_inset

。
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/subaochen/git/blog/imgs/java/type-erasure-class.eps
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
擦除类定义中的类型参数
\begin_inset CommandInset label
LatexCommand label
name "fig:擦除类定义中的类型参数"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
有限制类型擦除
\end_layout

\begin_layout Standard
当类定义中的类型参数存在限制（上下界）时，在类型擦除中替换为类型参数的上界或者下界，比如形如<T extends Number>和<? extends
 Number>的类型参数被替换为Number，<? super Number>被替换为Object，参见
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
figurename
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:擦除类定义中的有限制类型参数"

\end_inset

。
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/subaochen/git/blog/imgs/java/type-erasure-class-bounded.eps
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
擦除类定义中的有限制类型参数
\begin_inset CommandInset label
LatexCommand label
name "fig:擦除类定义中的有限制类型参数"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
擦除方法定义中的类型参数
\end_layout

\begin_layout Standard
擦除方法定义中的类型参数原则和擦除类定义中的类型参数是一样的，这里仅以擦除方法定义中的有限制类型参数为例，见
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
figurename
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:擦除泛型方法中的类型参数"

\end_inset

。
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/subaochen/git/blog/imgs/java/type-erasure-method.eps
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
擦除泛型方法中的类型参数
\begin_inset CommandInset label
LatexCommand label
name "fig:擦除泛型方法中的类型参数"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
通过jad反编译后的结果可以对照一下？
\end_layout

\end_inset


\end_layout

\begin_layout Section
桥接方法和泛型的多态
\end_layout

\begin_layout Standard
考虑下面的代码：
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface Info<T> {
\end_layout

\begin_layout Plain Layout

    // just return var:-) 
\end_layout

\begin_layout Plain Layout

    T info(T var); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

public class BridgeMethodTest implements Info<Integer> {
\end_layout

\begin_layout Plain Layout

    @Override
\end_layout

\begin_layout Plain Layout

    public Integer info(Integer var) {
\end_layout

\begin_layout Plain Layout

        return var;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
按照我们之前类型擦除的经验，在擦除类型后的代码应该是这个样子的：
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface Info {
\end_layout

\begin_layout Plain Layout

    // just return var
\end_layout

\begin_layout Plain Layout

    Object info(Object var);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class BridgeMethodTest implements Info {
\end_layout

\begin_layout Plain Layout

    @Override
\end_layout

\begin_layout Plain Layout

    public Integer info(Integer var) {
\end_layout

\begin_layout Plain Layout

        return var;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
但是，明显这样擦除类型后的代码语法上是错误的：BridgeMethodTest类中虽然存在一个info方法，但是和Info接口要求覆盖的info方法不一致：参数
类型不一致。
\end_layout

\begin_layout Section
Java多态对泛型的影响
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
什么情况下需要创建桥接方法？
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Java多态会影响泛型“类型检查”能力的发挥，比如在
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstlistingname
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "bridgeMethod-Node.java"

\end_inset

中，我们定义了一个Node<T>，在
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstlistingname
\end_layout

\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "bridgeMethod-MyNode.java"

\end_inset

中我们定义了一个MyNode类，MyNode从Node<Integer>继承下来。
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/subaochen/git/java-tutorial-examples/generic/src/cn/edu/sdut/softlab/bridgeMethod/Node.java"
lstparams "caption={Node.java},label={bridgeMethod-Node.java}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/subaochen/git/java-tutorial-examples/generic/src/cn/edu/sdut/softlab/bridgeMethod/MyNode.java"
lstparams "caption={MyNode.java},label={bridgeMethod-MyNode.java}"

\end_inset

MyNode编译并没有出错，但是运行MyNode会报告如下的错误：
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
Exception in thread "main" java.lang.ClassCastException: java.lang.String cannot
 be cast to java.lang.Integer
\end_layout

\begin_layout Plain Layout
at cn.edu.sdut.softlab.bridgeMethod.MyNode.setData(MyNode.java:6)
\end_layout

\begin_layout Plain Layout
at cn.edu.sdut.softlab.bridgeMethod.MyNode.main(MyNode.java:18)
\end_layout

\begin_layout Plain Layout
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
\end_layout

\begin_layout Plain Layout
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
\end_layout

\begin_layout Plain Layout
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java
:43)
\end_layout

\begin_layout Plain Layout
at java.lang.reflect.Method.invoke(Method.java:498)
\end_layout

\begin_layout Plain Layout
at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
这当然不是我们期望的！我们使用泛型的一个重要目的就是为了增强Java的
\begin_inset Flex Emph
status open

\begin_layout Plain Layout
类型安全
\end_layout

\end_inset

检查，使得Java在编译阶段就能发现这种类型不匹配的错误。
\end_layout

\begin_layout Standard
首先我们来分析一下MyNode为什么会发生运行时的异常。上述代码在经过类型擦除后会变成：
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class Node {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public Object data;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public Node(Object data) { this.data = data; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public void setData(Object data) {
\end_layout

\begin_layout Plain Layout

        System.out.println("Node.setData");
\end_layout

\begin_layout Plain Layout

        this.data = data;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class MyNode extends Node {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public MyNode(Integer data) { super(data); }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public void setData(Integer data) {
\end_layout

\begin_layout Plain Layout

        System.out.println("MyNode.setData");
\end_layout

\begin_layout Plain Layout

        super.setData(data);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

        MyNode mn = new MyNode(5); //|
\backslash
longremark{创建MyNode类型的对象，mn指向该对象，mn.data赋值为5}|
\end_layout

\begin_layout Plain Layout

        Node n = (MyNode)mn; //|
\backslash
longremark{引用n指向mn对象}|
\end_layout

\begin_layout Plain Layout

        n.setData("Hello"); // |
\backslash
longremark{n.setData("Hello")在语法上是合法的，因为n是Node<T>类型，n.setData的参数是Object。但是在上一步中，n其
实指向的是mn对象，即一个MyNode类型的对象，而MyNode覆盖了Node的setData方法，因此根据Java的多态，n.setData其实调用的是mn.se
tData方法，mn.setData方法的参数要求是一个Integer，因此这里抛出了一个类型强制转换异常。}|
\end_layout

\begin_layout Plain Layout

        Integer x = (String)mn.data;//|
\backslash
longremark{由于上一句抛出了异常，这一句执行不到}|
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

//|
\backslash
showremarks|
\end_layout

\end_inset


\end_layout

\begin_layout Standard
进一步的，我们假设MyNode没有覆盖Node的setData方法，即MyNode的定义如下：
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class MyNode extends Node<Integer> {
\end_layout

\begin_layout Plain Layout

    public MyNode(Integer data) { super(data); }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//    @Override
\end_layout

\begin_layout Plain Layout

//    public void setData(Integer data) {
\end_layout

\begin_layout Plain Layout

//        System.out.println("MyNode.setData");
\end_layout

\begin_layout Plain Layout

//        super.setData(data);
\end_layout

\begin_layout Plain Layout

//    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public static void main(String[] args) {
\end_layout

\begin_layout Plain Layout

        MyNode mn = new MyNode(5);
\end_layout

\begin_layout Plain Layout

        Node n = mn;            // A raw type - compiler throws an unchecked
 warning
\end_layout

\begin_layout Plain Layout

        n.setData("Hello");
\end_layout

\begin_layout Plain Layout

        Integer x = mn.data;    // Causes a ClassCastException to be thrown.
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
则执行结果如下：
\end_layout

\begin_layout Standard
\begin_inset Box Shaded
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
Node.setData
\end_layout

\begin_layout Plain Layout
Exception in thread "main" java.lang.ClassCastException: java.lang.String cannot
 be cast to java.lang.Integer
\end_layout

\begin_layout Plain Layout
at cn.edu.sdut.softlab.bridgeMethod.MyNode.main(MyNode.java:19)
\end_layout

\begin_layout Plain Layout
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
\end_layout

\begin_layout Plain Layout
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
\end_layout

\begin_layout Plain Layout
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java
:43)
\end_layout

\begin_layout Plain Layout
at java.lang.reflect.Method.invoke(Method.java:498)
\end_layout

\begin_layout Plain Layout
at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
我们分析一下为什么会出现这种结果：
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MyNode mn = new MyNode(5); //|
\backslash
longremark{创建MyNode类型的对象，mn指向该对象，mn.data赋值为5}|
\end_layout

\begin_layout Plain Layout

Node n = (MyNode)mn; //|
\backslash
longremark{引用n指向mn对象}|
\end_layout

\begin_layout Plain Layout

n.setData("Hello"); // |
\backslash
longremark{因为n是Node<T>类型，n.setData的参数是Object，因此这里可以将n.data赋值为字符串"Hello"}|
\end_layout

\begin_layout Plain Layout

Integer x = (String)mn.data;//|
\backslash
longremark{由于在上一句中data被赋值为String类型，Java推断Node<T>中的T为String类型,因此n.data为String类型。由于
mn和n都指向了同一个对象，因此mn.data亦为String类型，由此在这里会发生强制类型转换异常。}|
\end_layout

\begin_layout Plain Layout

//|
\backslash
showremarks|
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
经过验证，oracle docs中关于本部分的讲解应该是错误的
\end_layout

\end_inset


\end_layout

\begin_layout Section*
参考资料
\end_layout

\begin_layout Itemize
\begin_inset CommandInset href
LatexCommand href
name "http://docs.oracle.com/javase/tutorial/java/generics/index.html"
target "http://docs.oracle.com/javase/tutorial/java/generics/index.html"

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset CommandInset href
LatexCommand href
name "http://docs.oracle.com/javase/tutorial/extra/generics/index.html"
target "http://docs.oracle.com/javase/tutorial/extra/generics/index.html"

\end_inset


\end_layout

\end_body
\end_document
